# Vulnerability Remediation Guide

## SQL Injection

### Python (SQLite/PostgreSQL/MySQL)

**Vulnerable:**
```python
query = f"SELECT * FROM users WHERE username = '{username}'"
cursor.execute(query)
```

**Secure:**
```python
query = "SELECT * FROM users WHERE username = ?"
cursor.execute(query, (username,))
```

### JavaScript/Node.js (PostgreSQL with node-postgres)

**Vulnerable:**
```javascript
const query = `SELECT * FROM users WHERE username = '${username}'`;
client.query(query);
```

**Secure:**
```javascript
const query = 'SELECT * FROM users WHERE username = $1';
client.query(query, [username]);
```

## Cross-Site Scripting (XSS)

### Python (Flask)

**Vulnerable:**
```python
from flask import Markup
return Markup(f"<div>{user_input}</div>")
```

**Secure:**
```python
from markupsafe import escape
return f"<div>{escape(user_input)}</div>"
# Or use Jinja2 templates (auto-escapes by default)
```

### JavaScript (React)

**Vulnerable:**
```jsx
<div dangerouslySetInnerHTML={{__html: userInput}} />
```

**Secure:**
```jsx
<div>{userInput}</div>  {/* React escapes by default */}
```

### JavaScript (Vanilla)

**Vulnerable:**
```javascript
element.innerHTML = userInput;
```

**Secure:**
```javascript
element.textContent = userInput;
// Or sanitize with DOMPurify
element.innerHTML = DOMPurify.sanitize(userInput);
```

## Command Injection

### Python

**Vulnerable:**
```python
os.system(f"ping {user_input}")
subprocess.run(f"ls {directory}", shell=True)
```

**Secure:**
```python
# Use subprocess with list (no shell)
subprocess.run(["ping", user_input], shell=False)
subprocess.run(["ls", directory], shell=False)
```

### JavaScript/Node.js

**Vulnerable:**
```javascript
const { exec } = require('child_process');
exec(`ping ${userInput}`);
```

**Secure:**
```javascript
const { execFile } = require('child_process');
execFile('ping', [userInput]);
```

## Broken Access Control (IDOR)

### Python (Flask)

**Vulnerable:**
```python
@app.route('/users/<user_id>')
def get_user(user_id):
    user = db.get_user(user_id)  # No authorization check!
    return jsonify(user)
```

**Secure:**
```python
@app.route('/users/<user_id>')
@login_required
def get_user(user_id):
    # Check if current user can access this resource
    if current_user.id != user_id and not current_user.is_admin:
        abort(403)  # Forbidden
    
    user = db.get_user(user_id)
    return jsonify(user)
```

### JavaScript/Express

**Vulnerable:**
```javascript
app.get('/users/:id', (req, res) => {
    const user = db.getUser(req.params.id);
    res.json(user);
});
```

**Secure:**
```javascript
app.get('/users/:id', authenticate, (req, res) => {
    const requestedUserId = req.params.id;
    const currentUserId = req.user.id;
    
    // Authorization check
    if (requestedUserId !== currentUserId && !req.user.isAdmin) {
        return res.status(403).json({error: 'Forbidden'});
    }
    
    const user = db.getUser(requestedUserId);
    res.json(user);
});
```

## CSRF Protection

### Python (Flask with Flask-WTF)

```python
from flask_wtf.csrf import CSRFProtect

app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')
csrf = CSRFProtect(app)

# In templates:
# <form method="POST">
#   {{ csrf_token() }}
# </form>
```

### JavaScript (Express)

```javascript
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

app.use(csrfProtection);

app.get('/form', (req, res) => {
    res.render('form', { csrfToken: req.csrfToken() });
});

app.post('/process', (req, res) => {
    // CSRF token validated automatically
    res.send('Data processed');
});
```

## Insecure Deserialization

### Python

**Vulnerable:**
```python
import pickle
data = pickle.loads(user_input)  # DANGEROUS!
```

**Secure:**
```python
import json
data = json.loads(user_input)  # JSON is safe
# Validate structure after parsing
```

### JavaScript

**Vulnerable:**
```javascript
eval(userInput);  // NEVER DO THIS
```

**Secure:**
```javascript
JSON.parse(userInput);  // JSON.parse is safe
// Validate structure after parsing
```

## Weak Cryptography

### Python

**Vulnerable:**
```python
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()
```

**Secure:**
```python
import bcrypt

# Hashing
password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

# Verification
if bcrypt.checkpw(password.encode('utf-8'), stored_hash):
    print("Password correct")
```

### JavaScript/Node.js

**Vulnerable:**
```javascript
const crypto = require('crypto');
const hash = crypto.createHash('md5').update(password).digest('hex');
```

**Secure:**
```javascript
const bcrypt = require('bcrypt');
const saltRounds = 10;

// Hashing
const hash = await bcrypt.hash(password, saltRounds);

// Verification
const match = await bcrypt.compare(password, storedHash);
```

## Path Traversal

### Python

**Vulnerable:**
```python
filename = request.args.get('file')
with open(f'/files/{filename}') as f:
    return f.read()
```

**Secure:**
```python
import os
from werkzeug.utils import secure_filename

filename = secure_filename(request.args.get('file'))
filepath = os.path.join('/files', filename)

# Ensure path is within allowed directory
if not os.path.abspath(filepath).startswith('/files/'):
    abort(400)

with open(filepath) as f:
    return f.read()
```

## Rate Limiting

### Python (Flask-Limiter)

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route("/expensive")
@limiter.limit("10 per minute")
def expensive_operation():
    return "Result"
```

### JavaScript (Express-Rate-Limit)

```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100 // limit each IP to 100 requests per windowMs
});

app.use('/api/', limiter);
```

## Input Validation

### Python (Pydantic)

```python
from pydantic import BaseModel, EmailStr, conint

class UserCreate(BaseModel):
    email: EmailStr  # Validates email format
    age: conint(ge=0, le=150)  # Age between 0 and 150
    name: str

# Usage
try:
    user = UserCreate(**request_data)
except ValidationError as e:
    return jsonify({"errors": e.errors()}), 400
```

### JavaScript (Joi)

```javascript
const Joi = require('joi');

const schema = Joi.object({
    email: Joi.string().email().required(),
    age: Joi.number().integer().min(0).max(150).required(),
    name: Joi.string().min(1).max(100).required()
});

const { error, value } = schema.validate(req.body);
if (error) {
    return res.status(400).json({ error: error.details });
}
```
